---
layout: post
title: "关于HashMap底层的三个问题"
date: 2020-11-11
tags: 源码学习
---

HashMap作为日常开发中使用最多的对象，其底层如何添加元素、如何扩容、扩容可能产生的问题，以及从jdk7到jdk8做了哪些改进？这些问题从底层源码中都能找到答案，此处就3个比较感兴趣的问题做一些总结。

## 1 链表转红黑树问题

HashMap在jdk7版本做了一个重要的优化，即hash桶下的链表元素超过8个之后，链表将转红黑树。jdk7及之前的版本，无论链表多长，新增的元素时依然时往链表头部添加。当链表过长时就会导致元素的存取性能下降，所以jdk8中引入了红黑树，红黑树是一种平衡二叉树，规避了普通二叉树在极端情形可能转成链表的情况，其时间复杂度是O(lgn)，效率非常高，其特性如下：

（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

jdk8中HashMap的put方法中可以发现，当满足一定条件之后，会进入treeifyBin(tab, hash)方法(第37行代码)，该方法即执行链表转红黑树的操作；

```java

public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
}

/**
 * Implements Map.put and related methods
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to put
 * @param onlyIfAbsent if true, don't change existing value
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
			   boolean evict) {
	Node<K,V>[] tab; Node<K,V> p; int n, i;
	if ((tab = table) == null || (n = tab.length) == 0)
		n = (tab = resize()).length;
	if ((p = tab[i = (n - 1) & hash]) == null)
		tab[i] = newNode(hash, key, value, null);
	else {
		Node<K,V> e; K k;
		if (p.hash == hash &&
			((k = p.key) == key || (key != null && key.equals(k))))
			e = p;	
        //桶内对象已经是红黑树	
		else if (p instanceof TreeNode)
			e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
		else {
			//桶内已经存在普通节点则遍历链表，往链表尾部添加节点
			for (int binCount = 0; ; ++binCount) {
				if ((e = p.next) == null) {
					p.next = newNode(hash, key, value, null);
					//如果链表内的数据已经超过8个则将链表转成红黑树
					if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
						treeifyBin(tab, hash);
					break;
				}
				if (e.hash == hash &&
					((k = e.key) == key || (key != null && key.equals(k))))
					break;
				p = e;
			}
		}
		if (e != null) { // existing mapping for key
			V oldValue = e.value;
			if (!onlyIfAbsent || oldValue == null)
				e.value = value;
			afterNodeAccess(e);
			return oldValue;
		}
	}
	++modCount;
	if (++size > threshold)
		resize();
	afterNodeInsertion(evict);
	return null;
}

```

## 2 长度要求2的n次方问题

HashMap的默认长度是16，如下源码定义

```java
/**
* The default initial capacity - MUST be a power of two.
*/
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

其中，注释``MUST be a power of two``比较亮眼，即长度必须为<font color='red' >2的幂</font>，此处官方为什么要做这种限定呢？

HashMap为了减少hash碰撞，提高value的存取效率，需要尽量保证数据在数组上分配均匀，让每个链表的长度大致相同。当put(key, vlaue)元素时，第一步就是确定其所在桶的位置，即先对key进行hash运算，拿到key的hash值之后，在对length取模，即int index=hash(key)%length，index即为该元素所在桶的位置，但从源码中(如下代码段)我们看到，HashMap底层并没有采用``取模%``的方式得到桶的位置，而是使用了计算机中的``位&``运算，因为<font color='red'>位运算的效率要比取模运算要高</font>。

```java
/**
* Returns index for hash code h.
*/
static int indexFor(int h, int length) {
// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
return h & (length-1);
}
```

注意：``hash%length == hash&(length-1)``的前提是length是2的n次方

为什么这样能均匀分布减少碰撞呢？十进制转二进制时2的n次方实际是1后面n个0，2的n次方-1  实际是n个1；
例如长度为9时候，3&(9-1)=0  2&(9-1)=0 ，都在0号桶上，产生碰撞；
例如长度为8时候，3&(8-1)=3  2&(8-1)=2 ，不同位置上，未产生碰撞；

如何证明上述位运算hash&(length-1)的效率要比取模运算hash%length效率高呢？通过如下测试代码，最终跑出来的结果，前者用时要少于后者

```java
public static void main(String[] args) {
	int len = 1024;

	long t1 = System.currentTimeMillis();
	for(int i=0; i<1000000000;i++){
		int m = i % len;
	}

	long t2 = System.currentTimeMillis();
	for(int i=0; i<1000000000;i++){
		int m = i & (len-1);
	}
	long t3 = System.currentTimeMillis();

	System.out.println(" i % len 耗时: " + (t2-t1));
	System.out.println(" i & (len-1) 耗时: " + (t3-t2));
}

//得出结果如下：
 i % len 耗时: 6
 i & (len-1) 耗时: 1
```



## 3 扩容死循环问题

未完待续...

